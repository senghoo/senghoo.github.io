---
layout: post
title: SICP读书笔记2.2
tags: SICP
hidden: true

---

## 练习2.17

``` scheme
(define (last-pair l)
  (if (null? (cdr l))
      l
      (last-pair (cdr l))))
```


## 练习2.18

``` scheme
(define (reverse1 lst)
  (if (null? lst)
      '()
      (append (reverse1 (cdr lst)) (list (car lst)))))

```

## 练习2.19

``` scheme
(define (cc amount coin-values)
  (cond ((= amount 0) 1)
        ((or (< amount 0) (no-more? coin-values)) 0)
        (else
         (+ (cc amount (except-first-denomination coin-values))
            (cc (- amount (first-denomination coin-values)) coin-values)))))

(define (first-denomination x) (car x))
(define (except-first-denomination x) (cdr x))
(define (no-more? x) (null? x))
```

## 练习2.20

``` scheme
(define (same-parity . n)
  (define (same d)
    (or (and (even? d) (even? (car n)))
        (and (odd? d) (odd? (car n)))))
  (define (iter i)
    (cond
     ((null? i) '())
     ((same (car i))
      (cons (car i) (iter (cdr i))))
     (else (iter (cdr i)))))
  (iter n))
```

## 练习2.21

``` scheme
(define (square x) (* x x))
(define (square-list items)
  (if (null? items)
      '()
      (cons (square (car items)) (square-list (cdr items)))))

(define (square-list2 items)
  (map square items))
```

## 练习2.22

1. cons拼接的顺序错误
2. 拼接方法错误，应该使用append 追加到最后而不是使用cons拼接

可修改为：

``` scheme
(define (square-list items)
  (define (iter things answer)
    (if (null? things)
        answer
        (iter (cdr things)
              (append answer
                    (list (square (car things)))))))
  (iter items '()))
```


## 练习2.23

``` scheme
(define (for-each f lst)
  (when (not (null? lst))
    (f (car lst))
    (for-each2 f (cdr lst))))
```

## 练习2.24

`(1 (2 (3 4)))`

## 练习2.25

``` scheme
(car (cdr (car (cdr (cdr '(1 3 (5 7) 9))))))
(car (car '((7))))
(car (cdr (cdr (cdr '(1 (2 (3 (4 (5 (6 7))))))))))
(cadr (cadr (cadr (cadr (cadr (cadr '(1 (2 (3 (4 (5 (6 7))))))))))))
```

## 练习2.26

``` scheme
#;142> (define x (list 1 2 3))
#;174> (define y (list 4 5 6))
#;190> (append x y)
(1 2 3 4 5 6)
#;205> (cons x y)
((1 2 3) 4 5 6)
#;218> (list x y)
((1 2 3) (4 5 6))
```

## 练习2.27

``` scheme
(define (deep-reverse lst)
  (if (pair? lst)
      (reverse (map deep-reverse lst))
      lst))
```

## 练习2.28

``` scheme
(define (fringe tree)
  (cond ((pair? tree)
         (append (fringe (car tree)) (fringe (cdr tree))))
        ((null? tree) tree)
        (else (list tree))))

```

## 练习2.29

a)

``` scheme
(define (left-branch m) (car m))
(define (right-branch m) (cadr m))

(define (branch-length b) (car b))
(define (branch-structure b) (cadr b))
```

b)

``` scheme 
(define (mobile? b) (pair? (branch-structure b)))

(define (branch-weight b)
  (if (mobile? b)
      (total-weight (branch-structure b))
      (branch-structure b)))

(define (total-weight m)
  (+ (branch-weight (left-branch m))
     (branch-weight (right-branch m))))
```

c)

``` scheme
(define (balance? m)
  (let ((l (left-branch m))
        (r (right-branch m)))
    (and (= (* (branch-length l) (branch-weight l))
            (* (branch-length r) (branch-weight r)))
         (if (branch? r) (balance? r) #t)
         (if (branch? l) (balance? l) #t))))
```
 
d) 因为其他计算中都使用了题目a当中使用的封装实现，不关心结构实现细节，只需要修改题目a当中的部分函数就可以适应新的变化

## 练习2.30

``` scheme
(define (square-tree t)
  (cond ((pair? t)
         (cons (square-tree (car t)) (square-tree (cdr t))))
        ((null? t) '())
        (else (square t))))

(define (square-tree2 t)
  (if (pair? t)
      (map square-tree2 t)
      (square t)))
```

## 练习2.31

``` scheme
(define (tree-map f t)
  (define (iter t)
    (if (pair? t)
        (map square-tree2 t)
        (f t)))
  (iter t))
```

运行结果：

``` scheme
#;2390> (tree-map square (list 1 (list 2 (list 3 4) 5) (list 6 7)))
(1 (4 (9 16) 25) (36 49))
```

## 练习2.32

``` scheme
(define (subsets s)
  (if (null? s)
      (list '())
      (let ((rest (subsets (cdr s))))
        (append rest (map (lambda (r) (append r (list (car s)))) rest)))))
```
