---
layout: post
title: SICP读书笔记1.3
tags: SICP

---

## 练习1.29

解释器内部采用有理数表示，部分数值的关系，对于n = 100 和n = 1000的求值均得到0.25

``` scheme
(define (sum term a next b)
  (if (> a b)
      0
      (+ (term a)
         (sum term (next a) next b))))


(define (integral f a b n)
  (define h (/ (- b a) n))
  (define (term k)
    (define (y k)
      (f (+ a (* k h))))
    (cond ((= k 0) (y k))
          ((= k n) (y k))
          ((devides? 2 k) (* 2 (y k)))
          (else (* 4 (y k)))))
  (define (next n) (+ n 1))
  (* (/ h 3) (sum term 0 next n) ))

(define (devides? a b)
  (= (remainder b a) 0))
```

## 练习1.30

``` scheme
(define (sum term a next b)
  (define (iter a result)
    (if (> a b)
        result
        (iter (next a) (+ result (term a)))))
  (iter a 0))
```

## 练习1.31

a) product过程只需要修改上面的sum过程的 + 为 * ，并且把初始值变为1

``` scheme
(define (product term a next b)
  (define (iter a result)
    (if (> a b)
        result
        (iter (next a) (* result (term a)))))
  (iter a 1))

(define (pi n)
  (define (next a) (+ a 1))
  (define (term a)
    (if (devides? 2 a)
        (/ (+ a 2) (+ a 1))
        (/ (+ a 1) (+ a 2))))
  (* (product term 1 next n) 4))


(define (devides? a b)
  (= (remainder b a) 0))
```

b) 上面实现的是送代计算过程，实现递归过程，同样简单修改sum的递归过程就可以

``` scheme
(define (product2 term a next b)
  (if (> a b)
      1
      (* (term a)
         (product2 term (next a) next b))))
```


## 练习1.32

如同习题1.31把sum 变为product时所做的变化。在accumulate中运算符和初始值是通过参数传进来的。

也就是进一步抽象共同点，在更高层次上进行抽象。

accumulate的送代版本和递归版本如下：

``` scheme
(define (accumulate combiner null-value term a next b)
  (define (iter a result)
    (if (> a b)
        result
        (iter (next a) (combiner result (term a)))))
  (iter a null-value))

(define (accumulate2 combiner null-value term a next b)
  (if (> a b)
      null-value
      (combiner (term a)
                (product2 term (next a) next b))))
```

使用accumulate实现sum和product:

``` scheme
(define (product term a next b)
  (accumulate * 1 term a next b))

(define (sum term a next b)
  (accumulate + 0 term a next b))
```

## 练习1.33

定义过程如下:

``` scheme
(define (filtered-accumulate combiner null-value term a next b filter)
  (define (iter a result)
    (cond ((> a b) result)
          ((filter a) (iter (next a) (combiner result (term a))))
          (else (iter (next a) result))))
  (iter a null-value))
```

1) 

``` scheme
(define (square n) (* n n))

(define (smallest-divisor n)
  (find-divisor n 2))

(define (find-divisor n test-divisor)
  (cond ((> (square test-divisor) n) n)
        ((devides? test-divisor n) test-divisor)
        (else (find-divisor n (+ test-divisor 1)))))

(define (devides? a b)
  (= (remainder b a) 0))

(define (prime? n)
  (= n (smallest-divisor n)))

(define (prime-sum a b)
  (define (term x) x)
  (define (next x) (+ x 1))
  (filtered-accumulate + 0 term a next b prime?))
```

2)

``` scheme
(define (gcd a b)
  (if (= b 0)
      a
      (gcd b (remainder a b))))

(define (coprime-sum n)
  (define (coprime? x) (= (gcd n x) 1))
  (define (term x) x)
  (define (next x) (+ x 1))
  (filtered-accumulate + 0 term 1 next n coprime?))
```
